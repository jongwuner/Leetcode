
### 문제설명

num1, num2 수열을 입력받는다. 이 2개의 수열은 n개의 요소 중 k개의 요소를 선택하여 부분수열을 만들 수 있다. (1<k<n) num1의 부분수열 n1_1, n1_2, ... , n1_k와 num2의 부분수열 n2_1, n2_2, n2_3, ... , n2_k를 만들었을 때, (n1_1 + n1_2 + n1_3 + ... + n1_k) * min(n2_1, n2_2, n2_3, ... , n2_k) 값이 최대가 되는 값을 찾는 문제이다. 

### 솔루션

num1과 num2의 인덱스 순서를 보존한다는 전제하에(Pair처리), num2를 기준으로 내림차순 정렬을 하면, num1에서 i인덱스를 볼 때, 0 ~ i-1까지의 인덱스에서 k - 1개를 선택하여 최대가 되는 sum 값을 항상 보존할 수 있다. num2[i]에는 항상 곱해줘야하는 값이 정해져있다. O(N)의 탐색으로 (n1_1 + n1_2 + n1_3 + ... + n1_k) * min(n2_1, n2_2, n2_3, ... , n2_k) 값이 최대가 되는 값을 찾을 수 있다. O(N)


### 메모
- 이런 류의 num1, num2가 주어질 때, 어떤 조건이 더 까다로운 조건인지를 살펴보고, 어떤 수열을 기준으로 솔루션을 접근할 지 고민하는 게 필요하다. 
  - num1은 합의 최댓값을 구해야하며, num2는 min값을 구해야한다. 
- minHeap으로는 가장 작은 값으로부터 k개를 순서대로 뽑을 수 없다. 최악의 경우 선형 리스트의 길이만큼의 시간이 소요됨. O(N) 
- 그래서 i까지의 k-1개의 합이 최대가 되는 값을 구할때 지금까지의 값을 보존하고 있는 sum 변수, 최소값을 순서대로 보존하고 있는 minHeap을 활용한다는 아이디어
- k를 선택해야하는 부분 수열. 그 중에서 합인 Sum을 찾는 과정에서, Heap을 활용할 수 있겠다는 아이디어는 나중에도 계속 쓰일 것 같다. 
- 자료구조를 고려할 때는 다음과 같은 사항들을 고민하면 좋다
  - 자료구조에 담기는 요소 (int, string, pair<?,?>, list, bitmask)
  - 연산 종류와 연산을 하게 되는 조건 (ex. push, pop, top)
  - 연산 전처리 (num2 기준 내림차순 정렬. min값이니까 오름차순보다도 내림차순이 편함) 

### 접근과정

![image](https://user-images.githubusercontent.com/16419202/221361493-5bed8d7a-ce14-46ea-a7aa-0db640002e19.png)


###

![image](https://user-images.githubusercontent.com/16419202/221361513-4ddf5e84-98ae-4daa-8a11-347e6dda2294.png)

###

![image](https://user-images.githubusercontent.com/16419202/221361522-fe063211-6c49-451a-9c40-dac6b56842e1.png)

###

![image](https://user-images.githubusercontent.com/16419202/221361533-d0c72a5c-8fcd-49fd-b8f3-42fa7606d2d4.png)
