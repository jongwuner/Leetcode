### 알고리즘 정리

모든 요소를 문제에 주어진 규칙에 따라 짝수화 한 후에, 현재 리스트 상태의 최대값, 최소값 요소들을 MaxHeap, MinHeap에 각각 관리한다. (리스트의 모든 요소가 2개의 Heap에 Push된다.) 문제에서 구하고자 하는 것은 문제에서 주어진 Array 연산을 반복하여 리스트 요소들 중 (최대-최소)값들 중 최소값이다. (최대-최소)의 값을 줄이려면 직관적으로 최대값은 줄여가고, 최소값은 늘려가야한다. 비교적으로 이 문제에서는 최소값을 늘리는 게 단순하다. 현재 시점의 리스트 요소 중 최소값이 짝수 일경우, 최소값을 증가시키지 못한다. 최소값이 바뀌려면 리스트 내 다른 짝수 요소가 /2 연산을 통해 자기보다 작아진 경우에만 최소값이 될 수 있다. 최소값이 홀수일 경우에는 딱 1번 곱할 수 있다. 반면, 최댓값을 줄이는 과정은 여러번의 루프를 반복하는 경우도 있다. 어떤 시점에서 리스트 값이 최댓값이 홀수 일 경우, 그 자체가 최댓값으로 고정된다. 만약 이 최댓값보다 큰 최댓값이 등장하려면, 리스트 내 다른 홀수 요소가 x2 연산을 통해 지금 현재 홀수인 최댓값보다 커져야하는데, 해당 솔루션에서는 처음에 리스트를 모두 짝수화하여 전처리 해두었기 때문에, x2를 하게 될 홀수자체가 없는 상황이다. 홀수가 있다면, 짝수였던 최댓값 후보가 /2 를 반복하여 얻어진 결과다. 현재 시점의 홀수인 최댓값보다 다른 값이 커질 수는 없다. 

솔루션은 시점마다 MaxHeap의 루트값, MinHeap의 루트값을 조회해주고, 이전 (최대-최소)값과 항상 비교하여 답의 후보가 될 수 있다. 이 과정을 마치고, MaxHeap의 루트가 짝수일 경우, /2 연산을 한 결과를 MaxHeap과 MinHeap에 동시에 넣어준다. MaxHeap에서는 /2의 결과를 통해, 기존 리스트에서 다른 최댓값이 발생하거나, 아니면 이전 최댓값의 /2가 그대로 최대인 경우가 있을 것이다. MaxHeap에서 홀수를 만나는 순간, 루프를 탈출하면 된다. (현재 최댓값보다 커질 최댓값은 발생할 수 없음). MinHeap에서는 MaxHeap의 루트에서 /2 한 값을 넣어주면, 루트값이 갱신될 수 있다. 


### 1. 수학적 규칙을 발견하려고 접근 (O(1)인 수학문제가 아닐끼?)

실제로 수학적 규칙이었음. 홀수에다가는 x2를 한번 하면 바로 짝수가 되고, 짝수는 /2 를 여러번 할 수 있음. 그리고 문제에서 구하고자 하는 것은 x와 /의 최단 횟수가 아니라, 그냥 모든 연산과정에서 (최대-최소)의 최솟값이다. 홀수의 곱하기 성질, 짝수의 나누기 성질을 이용하여 전처리를 할 수 있겠다는 생각이 들었다. 일단 모두 곱해주고, 나누기만 하면 되는 상황을 만들어도 문제가 없다.

![image](https://user-images.githubusercontent.com/16419202/221330396-bae13105-f457-4da0-86cd-7ae585d93f99.png)


### 2. 최대-최소 값을 저장하는 자료구조를 활용해야하나? DP인가? 리스트 상태를 모두 보존해야하는가?

DP가 아닌 이유.... 잘 모르겠다. 결국 DP나 자료구조 활용하는 문제나 공통적인 것은 삽입, 조회를 O(1), O(logN) 안에 할 수 있어야한다는 점이다. 어떤 답을 도출하기 위해, 어떤 요소를 어떤 규칙으로 확인해야하는지 고민하는 것이 본질이다. 

확실한 건, 이 문제에서는 최댓값과 최솟값만 확인해도 된다라는 결론에 도달했다. 리스트의 모든 상태를 보존하는 것까지는 불필요하다. 불필요한 이유는 좀 더 생각해봐야겠지만, 우리가 구하고자 하는 것은 최대 최소의 변화인데, Priority Queue를 활용하면 최대값, 최소값들을 과정 상에서 O(logN), O(1)의 시간으로 쉽게 관리할 수 있다. 또한 어떤 시점에서의 특정 최댓값, 최솟값들을 확인할 수 있 수 있다. 


구하고자 하는 것도 연산과정에서의 (최대-최소)의 최솟값이며, 최댓값과 최솟값이 변할 때 그 요소들을 항상 자료구조에다가 삽입하고 조회하기 때문이다.

![image](https://user-images.githubusercontent.com/16419202/221330484-4101b476-36ee-4a78-aac1-e2de0bf41bc8.png)


### 3. 몇가지 의문

![image](https://user-images.githubusercontent.com/16419202/221330640-f8807145-8555-4927-b4b2-1345bbce5ad1.png)



### 기록.

- 알고리즘 파악하기 전에 다른 알고리즘을 습득하기가 참 어렵다. 아이디어가 부족한 상태에서 다른 사람들의 알고리즘을 받아들이면 계속 의문이 생기는데, 이것이 솔루션에 접근하는데 방해요소가 된다. 그래서 최대한 풀때 같이 푸는 게 좋음. 

- 문제해결과정에서 내가 떠올린 아이디어가 왜 아니었는지를 명확히 설명할 수 있어야한다. 이 글은 그래서 좀 신경써서 작성하였음.

- 이 문제에서 반례를 만들기가 왜 어려웠는지 생각해볼 필요가 있다. 

- 문제 규칙에서 전처리할 수 있는 부분을 찾아내는 게 진짜 중요하다는 것을 깨달았다. 
